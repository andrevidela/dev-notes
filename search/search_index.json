{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome \u00b6 This is a curated list of my notes. Notes here will be closer to mini-blog posts rather than the messy and disorganised version of my notes. Yet, they won't be too formal otherwise they will start taking too long to organise and write. You can find out what I'm currently working on by looking at my TASKS . Latest news \u00b6 05. Data Generic Programming Explains how to use type descriptions to write highly generic code without the need for macros or code-generation. 04. More things with exact usage goes into more things to do when you can mix exact usage annotation with dependent types. Checkout 03. Getting started with Idris a short tutorial about how to get started with idris with very little prior knowledge.","title":"Welcome"},{"location":"#welcome","text":"This is a curated list of my notes. Notes here will be closer to mini-blog posts rather than the messy and disorganised version of my notes. Yet, they won't be too formal otherwise they will start taking too long to organise and write. You can find out what I'm currently working on by looking at my TASKS .","title":"Welcome"},{"location":"#latest-news","text":"05. Data Generic Programming Explains how to use type descriptions to write highly generic code without the need for macros or code-generation. 04. More things with exact usage goes into more things to do when you can mix exact usage annotation with dependent types. Checkout 03. Getting started with Idris a short tutorial about how to get started with idris with very little prior knowledge.","title":"Latest news"},{"location":"Done%20previously/","text":"Last week \u00b6 done after last week hide edit button Last month \u00b6 done after last month hide edit button","title":"Last week"},{"location":"Done%20previously/#last-week","text":"done after last week hide edit button","title":"Last week"},{"location":"Done%20previously/#last-month","text":"done after last month hide edit button","title":"Last month"},{"location":"TASKS/","text":"Projects : \u00b6 Here are the projects I'm currently working on Myrmidon A programming language leveraging QTT to control partial evaluation Open servers A Library to write web servers using lenses Open Games An programming language to write Open Games Idris Profficiency A short tutorial to get started with Idris Servers Lens tutorial A tutorial about open-servers as a library Done: \u00b6 Mailbox \u00b6 [-] Reproduce bug about namespaces and non-total functions at typechecking NOTE: If you implement a function f inside a module NS and you create an additional namespace NS inside your module and have another function f inside it. Then implementing the nested f ( NS.NS.f ) as f = NS.f won't refer to the f at the top level module, but will refer to itself. This is obviously not total, and if you call NS.NS.f then it will loop forever. If NS.NS.f happens to occur at compile-time, the typechecker will hang forever. NOTE: I gave up, it takes too much time and it's too finnicky. Fix prolude with latest Idris version \u2705 2021-12-07 install LSP \u2705 2021-12-05 fix the injection PR \u2705 2021-11-10 fix the parser PR \u2705 2021-11-10 1 install Scala 3 1.1 implement STLC with Match types ??? -- didn't work 2 figure out a DSL for programs 2.5 Check the injectivity pull request 2.6 Finish the dev notes about Idris2 2.7 Write the documentation for string interpolation concat fix the PR about injection \u2705 2021-11-23 move all NPL Org into gitlab Complete linear PR \u2705 2022-01-31 Write abstract for Dependent types talk in March \u2705 2022-02-05 3 Myrmidon language \u00b6 3.1 finish the parser (15.11.2021) 3.2 add Nat (14.11.2021) 3.6 compile surface syntax into AST 3.7 Add grades (14.12.2021) 3.7.1 fix typechecker (16.11.2021) 3.7.2 fix subst (17.11.2021) 3.7.3 fix Quoting (17.11.2021) 3.7.4 Abstract over the grades in context (14.12.2021) NOTE: this was already done but I just noticed today \u2705 2021-12-14 3.9 Add a Scheme codegen \u2705 2022-01-04 5 OpenGames things \u00b6 5.1 use mwc-prob to port to singletons NOTE: it didn't work because singletons cannot promote constrained constructors NOTE: Maybe worth porting the probability library without mwc-prob 5.2 use mwc-prob to port to Idris NOTE: didn't work either NOTE: (09.12.2021) I don't remember what this is 5.4 Port the preprocessor to the updated version (13.12.2021) 6 Open-Servers \u00b6 6.1 port the core logic to indexed paths 6.3 change type of GET request to implement lenses instead of functions to lenses (07.12.2021 - in reality done much earlier but I forgot to track the change) 6.4 implement the dep-lens EDSL (07.12.2021) NOTES: kind of works but is blocked by 6.6 6.6 Implement servers as Dependent Para lenses (09.01.2022) 6.6.1 implement server as a dependent lens rather than rely on the DSL (18.12.2021) 6.6.2 Implement routing as products of extended lenses rather than rely on Str path components (21.01.2022) 6.6.3 Fix an issue where the state could not be update because it depends on the input type of the request (01.01.2022) 6.6.4 Fix issue with dependent lenses where composition would not terminate (03.01.2022) 6.6.5 Implement the missing dependent interfaces dependening on server , aka implement instanceLens (05.01.2022) 6.6.6 reimplement server as external choice of existing servers (05.01.2022) COMMIT: e5995e537c2990 6.6.7 Implement a server as external choice but with a top level path (05.01.2022) NOTE: AKA /lights \u2576\u252c\u2574/kitchen \u2514\u2574/bedroom COMMIT: 7f1260385e 6.6.8 Rewrite a DSL for dependent para lens and give it a ServerInstance implementation ^5e3aef (06.01.2022) NOTE: It's working but two things are strange: we need some sort of Update interface which ensures we can update the final state from some substate Our State constructor requires the overall state to be parsable but that is not necessary if we don't expose the POST part of the endpoint 6.6.9 Fix the MR review comments (09.01.2022) 6.10 Make it possible to have endpoints with arguments in the middle 7 Data generic programming \u00b6 7.1 implement in terms of CFTprogramming (10.11.2021) 7.2 implement in terms of typedefs (10.11.2021) NOTE: didn't work because typedefs are broken 7.5 write the blog post about SplitN (10.11.2021) 8 Idris proefficiency tutorial \u00b6 8.1 collect funtions from last AOC (14.11.2021) 8.2 store helper functions in a library (23.11.2021) 8.2.1 queues and zippers (16.11.2021) 8.2.2 n-dimensional spaces (23.11.2021) 8.2.3 binary manipulation (23.11.2021) 8.2.4 Cryptography (23.11.2021) 9 Graphics \u00b6 9.2 Draw logo for myrmidon 10 OPLSS \u00b6 Understand and write about W-types containers <-> Polynomial functors Write n-ary functors Link up fixpoints of containers with fixpoints of polynomial functors and recover cata from it Metamorphisms Check if stream can use List instead of Maybe for non-deterministic buffers Check if it can work on any 1 + n functor so you can have non-determinism on trees Sequent calculus Categorical semantics implement SC in agda/Idris product and co-products aren't symetric??? Reading Review Clowns to the left, jokers to the right Review Fractional types from Dorchard Review Composing Bidirectional programs monadically Implement Jeremy's paper about breath-first search tree-traversal Could this be used for a more general version of traversing data structures without respecting their original definitions? Figure out the link between zippers and lenses Any link with derivatives? Merge oplss lenses and poly from Neko into TypesLab Merge oplss and state-machines from algae into TypesLab","title":"Projects :"},{"location":"TASKS/#projects","text":"Here are the projects I'm currently working on Myrmidon A programming language leveraging QTT to control partial evaluation Open servers A Library to write web servers using lenses Open Games An programming language to write Open Games Idris Profficiency A short tutorial to get started with Idris Servers Lens tutorial A tutorial about open-servers as a library","title":"Projects :"},{"location":"TASKS/#done","text":"","title":"Done:"},{"location":"TASKS/#mailbox","text":"[-] Reproduce bug about namespaces and non-total functions at typechecking NOTE: If you implement a function f inside a module NS and you create an additional namespace NS inside your module and have another function f inside it. Then implementing the nested f ( NS.NS.f ) as f = NS.f won't refer to the f at the top level module, but will refer to itself. This is obviously not total, and if you call NS.NS.f then it will loop forever. If NS.NS.f happens to occur at compile-time, the typechecker will hang forever. NOTE: I gave up, it takes too much time and it's too finnicky. Fix prolude with latest Idris version \u2705 2021-12-07 install LSP \u2705 2021-12-05 fix the injection PR \u2705 2021-11-10 fix the parser PR \u2705 2021-11-10 1 install Scala 3 1.1 implement STLC with Match types ??? -- didn't work 2 figure out a DSL for programs 2.5 Check the injectivity pull request 2.6 Finish the dev notes about Idris2 2.7 Write the documentation for string interpolation concat fix the PR about injection \u2705 2021-11-23 move all NPL Org into gitlab Complete linear PR \u2705 2022-01-31 Write abstract for Dependent types talk in March \u2705 2022-02-05","title":"Mailbox"},{"location":"TASKS/#3-myrmidon-language","text":"3.1 finish the parser (15.11.2021) 3.2 add Nat (14.11.2021) 3.6 compile surface syntax into AST 3.7 Add grades (14.12.2021) 3.7.1 fix typechecker (16.11.2021) 3.7.2 fix subst (17.11.2021) 3.7.3 fix Quoting (17.11.2021) 3.7.4 Abstract over the grades in context (14.12.2021) NOTE: this was already done but I just noticed today \u2705 2021-12-14 3.9 Add a Scheme codegen \u2705 2022-01-04","title":"3 Myrmidon language"},{"location":"TASKS/#5-opengames-things","text":"5.1 use mwc-prob to port to singletons NOTE: it didn't work because singletons cannot promote constrained constructors NOTE: Maybe worth porting the probability library without mwc-prob 5.2 use mwc-prob to port to Idris NOTE: didn't work either NOTE: (09.12.2021) I don't remember what this is 5.4 Port the preprocessor to the updated version (13.12.2021)","title":"5 OpenGames things"},{"location":"TASKS/#6-open-servers","text":"6.1 port the core logic to indexed paths 6.3 change type of GET request to implement lenses instead of functions to lenses (07.12.2021 - in reality done much earlier but I forgot to track the change) 6.4 implement the dep-lens EDSL (07.12.2021) NOTES: kind of works but is blocked by 6.6 6.6 Implement servers as Dependent Para lenses (09.01.2022) 6.6.1 implement server as a dependent lens rather than rely on the DSL (18.12.2021) 6.6.2 Implement routing as products of extended lenses rather than rely on Str path components (21.01.2022) 6.6.3 Fix an issue where the state could not be update because it depends on the input type of the request (01.01.2022) 6.6.4 Fix issue with dependent lenses where composition would not terminate (03.01.2022) 6.6.5 Implement the missing dependent interfaces dependening on server , aka implement instanceLens (05.01.2022) 6.6.6 reimplement server as external choice of existing servers (05.01.2022) COMMIT: e5995e537c2990 6.6.7 Implement a server as external choice but with a top level path (05.01.2022) NOTE: AKA /lights \u2576\u252c\u2574/kitchen \u2514\u2574/bedroom COMMIT: 7f1260385e 6.6.8 Rewrite a DSL for dependent para lens and give it a ServerInstance implementation ^5e3aef (06.01.2022) NOTE: It's working but two things are strange: we need some sort of Update interface which ensures we can update the final state from some substate Our State constructor requires the overall state to be parsable but that is not necessary if we don't expose the POST part of the endpoint 6.6.9 Fix the MR review comments (09.01.2022) 6.10 Make it possible to have endpoints with arguments in the middle","title":"6 Open-Servers"},{"location":"TASKS/#7-data-generic-programming","text":"7.1 implement in terms of CFTprogramming (10.11.2021) 7.2 implement in terms of typedefs (10.11.2021) NOTE: didn't work because typedefs are broken 7.5 write the blog post about SplitN (10.11.2021)","title":"7 Data generic programming"},{"location":"TASKS/#8-idris-proefficiency-tutorial","text":"8.1 collect funtions from last AOC (14.11.2021) 8.2 store helper functions in a library (23.11.2021) 8.2.1 queues and zippers (16.11.2021) 8.2.2 n-dimensional spaces (23.11.2021) 8.2.3 binary manipulation (23.11.2021) 8.2.4 Cryptography (23.11.2021)","title":"8 Idris proefficiency tutorial"},{"location":"TASKS/#9-graphics","text":"9.2 Draw logo for myrmidon","title":"9 Graphics"},{"location":"TASKS/#10-oplss","text":"Understand and write about W-types containers <-> Polynomial functors Write n-ary functors Link up fixpoints of containers with fixpoints of polynomial functors and recover cata from it Metamorphisms Check if stream can use List instead of Maybe for non-deterministic buffers Check if it can work on any 1 + n functor so you can have non-determinism on trees Sequent calculus Categorical semantics implement SC in agda/Idris product and co-products aren't symetric??? Reading Review Clowns to the left, jokers to the right Review Fractional types from Dorchard Review Composing Bidirectional programs monadically Implement Jeremy's paper about breath-first search tree-traversal Could this be used for a more general version of traversing data structures without respecting their original definitions? Figure out the link between zippers and lenses Any link with derivatives? Merge oplss lenses and poly from Neko into TypesLab Merge oplss and state-machines from algae into TypesLab","title":"10 OPLSS"},{"location":"Todo%20view/","text":"Mailbox \u00b6 not done heading includes mailbox hide backlink Myrmidon \u00b6 not done heading includes Myrmidon hide backlink Open Games \u00b6 not done heading includes 5 hide backlink Open servers \u00b6 not done heading includes 6 hide backlink Data Generic Programming \u00b6 not done heading includes 7 hide backlink Idris Profficiency \u00b6 not done heading includes 8 hide backlink Graphics \u00b6 not done heading includes 9 hide backlink Servers Lens tutorial \u00b6 not done heading includes 10 hide backlink Control room \u00b6 not done heading includes 11 hide backlink TASKS#10 OPLSS \u00b6 not done heading includes OPLSS hide backlink","title":"Todo view"},{"location":"Todo%20view/#mailbox","text":"not done heading includes mailbox hide backlink","title":"Mailbox"},{"location":"Todo%20view/#myrmidon","text":"not done heading includes Myrmidon hide backlink","title":"Myrmidon"},{"location":"Todo%20view/#open-games","text":"not done heading includes 5 hide backlink","title":"Open Games"},{"location":"Todo%20view/#open-servers","text":"not done heading includes 6 hide backlink","title":"Open servers"},{"location":"Todo%20view/#data-generic-programming","text":"not done heading includes 7 hide backlink","title":"Data Generic Programming"},{"location":"Todo%20view/#idris-profficiency","text":"not done heading includes 8 hide backlink","title":"Idris Profficiency"},{"location":"Todo%20view/#graphics","text":"not done heading includes 9 hide backlink","title":"Graphics"},{"location":"Todo%20view/#servers-lens-tutorial","text":"not done heading includes 10 hide backlink","title":"Servers Lens tutorial"},{"location":"Todo%20view/#control-room","text":"not done heading includes 11 hide backlink","title":"Control room"},{"location":"Todo%20view/#tasks10-oplss","text":"not done heading includes OPLSS hide backlink","title":"TASKS#10 OPLSS"},{"location":"Kanban/Writing%20board/","text":"To do \u00b6 Done \u00b6 Complete - [x] Fix titlescase - [x] Change size of texttt - [x] color code samples - [x] fix smallsc for mentions of recombine - [x] mention the plan in the intro - [x] primer on idris syntax - [x] flesh out contributions and introduction - [x] section 5 open servers - [x] section 4 dependent lenses - [x] section 3 resources + endpoints - [x] section 2 poly lenses - [x] section 6 recombine library - [x] Conclusion + future - [x] intro + contrib - [x] redo todo app example - [x] captures - [x] Syntax coloring for code in sectio n2 - [x] Add listings for diagrams - [x] latex CI - [x] Diagram for reparametrization - [x] draw boundaries on lens as string diagram %% kanban:settings {\"kanban-plugin\":\"basic\"} %%","title":"Writing board"},{"location":"Kanban/Writing%20board/#to-do","text":"","title":"To do"},{"location":"Kanban/Writing%20board/#done","text":"Complete - [x] Fix titlescase - [x] Change size of texttt - [x] color code samples - [x] fix smallsc for mentions of recombine - [x] mention the plan in the intro - [x] primer on idris syntax - [x] flesh out contributions and introduction - [x] section 5 open servers - [x] section 4 dependent lenses - [x] section 3 resources + endpoints - [x] section 2 poly lenses - [x] section 6 recombine library - [x] Conclusion + future - [x] intro + contrib - [x] redo todo app example - [x] captures - [x] Syntax coloring for code in sectio n2 - [x] Add listings for diagrams - [x] latex CI - [x] Diagram for reparametrization - [x] draw boundaries on lens as string diagram %% kanban:settings {\"kanban-plugin\":\"basic\"} %%","title":"Done"},{"location":"Programming/01.%20Emulating%20exact-usage%20in%20Idris2/","text":"Note n\u00ba1: Emulating exact usage in Idris2 \u00b6 Idris2 is a programming language featuring Quantitative Type Theory. In its current implementation Idris2 uses the semiring \\(\\{0, 1, \\omega\\}\\) which represent usage of a variable. Here, 0 indicates erasure 1 indicates linearity and \u03c9 represents unrestricted usage. Here is an example: map : (f : (1 v : a) -> b) -> (1 ls : LList a) -> LList b map f [] = [] map f (x :: xs) = f x :: map f xs This is the map function defined on linear lists , a linear list is just like a list, except all its constructors are linear, which means we must consume each list exactly once. As you can see, the function f is also linear, it takes a v : a that can be used only once and return a value of type b . Crucially, you will notice that f itself does not have a quantity associated with it, that means it's unrestricted, it can be used however meany times we want (including 0 times). Now let's do the same with vectors: map : (f : (1 v : a) -> b) -> (1 vs : LVect n a) -> LVect n b map f [] = [] map f (x :: xs) = f x :: map f xs In terms of implementation, this is what we expected. But notice the type signature: It is unchanged, even if we know how many times f will be used. It will be used exactly n times. This is because Idris2's semiring does not allow us to express exact usage beyond 0 and 1 use. However we can trick it: map : (0 f : (1 v : a) -> b) -> {auto 1 copies : Copies n f} -> (1 vs : LVect n a) -> LVect n b map f [] {copies = Done} = [] map f (x :: xs) {copies = (More f cs)} = f x :: map f xs {copies=cs} In this program f has 0 uses, however it is accompanied with copies which holds n copies of f itself. Since copies has usage 1 it must be entirely consumed, forcing us to make use of every since copy that's available to us. In the implementation we pattern-match on copies in order to extract the relevant (pun intended) copy of f and use it on the values of the vectors to create a new vector. The auto keyword is just there so that we don't have to write down the copies manually every time we want to use map . The only mystery remaining is to explain how Copies is implemented. And it's fortunately fairly simple: It's a linear vector that can only keep one single element. data Copies : Nat -> (0 v : a) -> Type where Done : Copies 0 v More : (1 v : a) -> (1 _ : Copies n v) -> Copies (S n) v This way if we have a value Copies 3 \"hello\" we get three copies of the value \"hello\" . You will notice in the type of Copies that the value itself must have 0 uses, that's because this only occurs in the type the value must be sorted in the More constructor rather than be pulled from the type. Just to check it works we can write a simple test: testMap : Vectors.map LSucc [0,1,2,3] === [1,2,3,4] testMap = Refl Where LSucc is the successor function for linear Nat . Thanks to Copies we can now write programs that indicate exactly how many times a variable is used, even if the usage values we have are only 0 1 and \u03c9 .","title":"Note n\u00ba1: Emulating exact usage in Idris2"},{"location":"Programming/01.%20Emulating%20exact-usage%20in%20Idris2/#note-no1-emulating-exact-usage-in-idris2","text":"Idris2 is a programming language featuring Quantitative Type Theory. In its current implementation Idris2 uses the semiring \\(\\{0, 1, \\omega\\}\\) which represent usage of a variable. Here, 0 indicates erasure 1 indicates linearity and \u03c9 represents unrestricted usage. Here is an example: map : (f : (1 v : a) -> b) -> (1 ls : LList a) -> LList b map f [] = [] map f (x :: xs) = f x :: map f xs This is the map function defined on linear lists , a linear list is just like a list, except all its constructors are linear, which means we must consume each list exactly once. As you can see, the function f is also linear, it takes a v : a that can be used only once and return a value of type b . Crucially, you will notice that f itself does not have a quantity associated with it, that means it's unrestricted, it can be used however meany times we want (including 0 times). Now let's do the same with vectors: map : (f : (1 v : a) -> b) -> (1 vs : LVect n a) -> LVect n b map f [] = [] map f (x :: xs) = f x :: map f xs In terms of implementation, this is what we expected. But notice the type signature: It is unchanged, even if we know how many times f will be used. It will be used exactly n times. This is because Idris2's semiring does not allow us to express exact usage beyond 0 and 1 use. However we can trick it: map : (0 f : (1 v : a) -> b) -> {auto 1 copies : Copies n f} -> (1 vs : LVect n a) -> LVect n b map f [] {copies = Done} = [] map f (x :: xs) {copies = (More f cs)} = f x :: map f xs {copies=cs} In this program f has 0 uses, however it is accompanied with copies which holds n copies of f itself. Since copies has usage 1 it must be entirely consumed, forcing us to make use of every since copy that's available to us. In the implementation we pattern-match on copies in order to extract the relevant (pun intended) copy of f and use it on the values of the vectors to create a new vector. The auto keyword is just there so that we don't have to write down the copies manually every time we want to use map . The only mystery remaining is to explain how Copies is implemented. And it's fortunately fairly simple: It's a linear vector that can only keep one single element. data Copies : Nat -> (0 v : a) -> Type where Done : Copies 0 v More : (1 v : a) -> (1 _ : Copies n v) -> Copies (S n) v This way if we have a value Copies 3 \"hello\" we get three copies of the value \"hello\" . You will notice in the type of Copies that the value itself must have 0 uses, that's because this only occurs in the type the value must be sorted in the More constructor rather than be pulled from the type. Just to check it works we can write a simple test: testMap : Vectors.map LSucc [0,1,2,3] === [1,2,3,4] testMap = Refl Where LSucc is the successor function for linear Nat . Thanks to Copies we can now write programs that indicate exactly how many times a variable is used, even if the usage values we have are only 0 1 and \u03c9 .","title":"Note n\u00ba1: Emulating exact usage in Idris2"},{"location":"Programming/03.%20Getting%20started%20with%20Idris/","text":"Getting started with Idris \u00b6 Idris is an experimental programming language with a lot of fancy features, most importantly dependent types and quantities . In this document I will provide basic information about how to use Idris and show what's neat about it A note about installation \u00b6 This will not cover how to install idris. For this refer to the installation instructions . There is a video tutorial about how to do it for windows . Installing Idris can sometimes not work for a lot of various reasons, every computer is different and the team isn't big enough to catch all possible edge cases. So if you have a problem with installation, head to the idris Discord server . Types and functions \u00b6 Idris being a functional programming language it deals with two basic concepts: Types and functions . Type tell what the program is supposed to do, functions implement what the types say: sayHello : (personName : String) -> String sayHello personName = \"hello \\{personName}!\" This is an example of a function, it takes a piece of text, which is described by the type String and returns a new piece of text. This is described by the type (name : String) -> String . Notice on the left of the arrow, the type has personName written in front of it. This is to give a name to the argument of the function. The function itself has a name sayHello . The first line sayHello : (personName : String) -> String declares the type of the function and the second line sayHello personName = \"hello \\{personName}!\" declares the implementation of the function. Running programs \u00b6 The example above is fairly basic but actually does something, provided we can run it. For this we are going to need to do the following: Create a file called \"Main.idr\" Write a main function Compile and run our program using the Idris compiler Create a main function \u00b6 For tidiness purposes we are going to put our files in a folder, so create one and call it Tutorial . Then go inside it and create the file Main.idr . Add the line module Main at the top and then paste the code : sayHello : (personName : String) -> String sayHello personName = \"hello \\{personName}!\" Which is the same we've seen above. Writing a main function \u00b6 The main function is the one that will be called when the program starts. Just like our previous function it needs both a Type and an implementation . The type of the main function is IO () , that is the type of interactive programs. The implementation will be a program that prints the content of the text of the sayHello function into the console. For this we use the printLn (it stands for \"print line\") function. Here is the code: main : IO () main = printLn (sayHello \"Susan\") We will see later how to make those programs interactive. Build & run our program \u00b6 To see the result of our work, we need to compile our program first. This will check our program for mistakes and will generate an executable file that your computer can run. For this we need two commands: idris2 -o main Main.idr This will compile the program and generate the executable. build/exec/main This will run the program we just compiled. If everything goes well, the line \"hello Susan!\" should appear on the screen. Making our program interactive \u00b6 The natural next step is to be able to write our own name and have the compter greet us! The simplest way to achieve this is to replace \"Susan\" by !getLine . The main function looks like this now: main : IO () main = printLn (sayHello !getLine) nb: Some of your familiar with other programing languages might have learned that ! is an operator that flip boolean values, but here it allows to combine multiple interactive programs together. We will see that later If you run your program using the same technique as before, you will get\u2026Nothing! That's because the computer is waiting for you to type some text and then hit the enter key to send it to the program. So if we type John And hit enter , we get: $ \"hello John!\" The computer responded and gave the correct name!","title":"Getting started with Idris"},{"location":"Programming/03.%20Getting%20started%20with%20Idris/#getting-started-with-idris","text":"Idris is an experimental programming language with a lot of fancy features, most importantly dependent types and quantities . In this document I will provide basic information about how to use Idris and show what's neat about it","title":"Getting started with Idris"},{"location":"Programming/03.%20Getting%20started%20with%20Idris/#a-note-about-installation","text":"This will not cover how to install idris. For this refer to the installation instructions . There is a video tutorial about how to do it for windows . Installing Idris can sometimes not work for a lot of various reasons, every computer is different and the team isn't big enough to catch all possible edge cases. So if you have a problem with installation, head to the idris Discord server .","title":"A note about installation"},{"location":"Programming/03.%20Getting%20started%20with%20Idris/#types-and-functions","text":"Idris being a functional programming language it deals with two basic concepts: Types and functions . Type tell what the program is supposed to do, functions implement what the types say: sayHello : (personName : String) -> String sayHello personName = \"hello \\{personName}!\" This is an example of a function, it takes a piece of text, which is described by the type String and returns a new piece of text. This is described by the type (name : String) -> String . Notice on the left of the arrow, the type has personName written in front of it. This is to give a name to the argument of the function. The function itself has a name sayHello . The first line sayHello : (personName : String) -> String declares the type of the function and the second line sayHello personName = \"hello \\{personName}!\" declares the implementation of the function.","title":"Types and functions"},{"location":"Programming/03.%20Getting%20started%20with%20Idris/#running-programs","text":"The example above is fairly basic but actually does something, provided we can run it. For this we are going to need to do the following: Create a file called \"Main.idr\" Write a main function Compile and run our program using the Idris compiler","title":"Running programs"},{"location":"Programming/03.%20Getting%20started%20with%20Idris/#create-a-main-function","text":"For tidiness purposes we are going to put our files in a folder, so create one and call it Tutorial . Then go inside it and create the file Main.idr . Add the line module Main at the top and then paste the code : sayHello : (personName : String) -> String sayHello personName = \"hello \\{personName}!\" Which is the same we've seen above.","title":"Create a main function"},{"location":"Programming/03.%20Getting%20started%20with%20Idris/#writing-a-main-function","text":"The main function is the one that will be called when the program starts. Just like our previous function it needs both a Type and an implementation . The type of the main function is IO () , that is the type of interactive programs. The implementation will be a program that prints the content of the text of the sayHello function into the console. For this we use the printLn (it stands for \"print line\") function. Here is the code: main : IO () main = printLn (sayHello \"Susan\") We will see later how to make those programs interactive.","title":"Writing a main function"},{"location":"Programming/03.%20Getting%20started%20with%20Idris/#build-run-our-program","text":"To see the result of our work, we need to compile our program first. This will check our program for mistakes and will generate an executable file that your computer can run. For this we need two commands: idris2 -o main Main.idr This will compile the program and generate the executable. build/exec/main This will run the program we just compiled. If everything goes well, the line \"hello Susan!\" should appear on the screen.","title":"Build &amp; run our program"},{"location":"Programming/03.%20Getting%20started%20with%20Idris/#making-our-program-interactive","text":"The natural next step is to be able to write our own name and have the compter greet us! The simplest way to achieve this is to replace \"Susan\" by !getLine . The main function looks like this now: main : IO () main = printLn (sayHello !getLine) nb: Some of your familiar with other programing languages might have learned that ! is an operator that flip boolean values, but here it allows to combine multiple interactive programs together. We will see that later If you run your program using the same technique as before, you will get\u2026Nothing! That's because the computer is waiting for you to type some text and then hit the enter key to send it to the program. So if we type John And hit enter , we get: $ \"hello John!\" The computer responded and gave the correct name!","title":"Making our program interactive"},{"location":"Programming/04.%20More%20things%20with%20exact%20usage/","text":"Exact usage and branching \u00b6 This thread from @dorchard inspired me to re-use the exact-usage hack of Idris2 to see if I could implement this particular feature of Granule . But you can also use dependence to then say whether something is used or not. For example we can make an optional (Maybe type) with a tag on it that it used to determine if a default is needed: pic.twitter.com/lBugAZn3lp \u2014 Dominic Orchard (@dorchard) October 20, 2021 By the way, granule is a great project full of great ideas and I strongly encourage you to take a look! Try downloading the examples and play with them, the project comes with a very nice tutorial . To make this work in Idris, we're going to use the same Copies data structure than in 01. Emulating exact-usage in Idris2 . More precisely, we need to make 1 copy of the value def if the value is missing and 0 if the value is present (since we're not going to use it). fromMaybe would then take the value def and the number of Copies we get depend on the Maybe value, we're going to call it m . So we need a way to get 0 or one depending on m , let's write this function and call it NotFound NotFound : Maybe a -> Nat NotFound Nothing = 1 NotFound (Just x) = 0 And now fromMaybe takes a value m , a default value def and a number of copies of def equal to the number returned by NotFound : fromMaybe : (1 m : Maybe a) -> (0 def : a) -> {auto 1 defs : Copies (NotFound m) def} -> a fromMaybe Nothing {defs = (More def Done)} def = def fromMaybe (Just x) {defs = Done} def = x and it works as expected! With this type signature it is impossible to implement the wrong function as the argument def won't be available if the value m is Just x . It turns out we can generalise this approach to other branching operators. For example an if function would use its first branch if the condition is true and its second branch if the condition is false. In our case it would mean that the number of copies for the first branch is equal to 1 for True and 0 for False and likewise (but reversed) for the second branch: IfTrue : Bool -> Nat IfTrue True = 1 IfTrue False = 0 IfFalse : Bool -> Nat IfFalse True = 0 IfFalse False = 1 ifQty : (1 switch : Bool) -> (0 tt, ff : b) -> {auto 1 trues : Copies (IfTrue switch) tt} -> {auto 1 falses : Copies (IfFalse switch) ff} -> b ifQty False tt ff {trues = Done} {falses = (More ff Done)} = ff ifQty True tt ff {trues = (More tt Done)} {falses = Done} = tt In case you find it weird to pass an argument that's never used but a proof that is used, you can do the opposite and make the value implicit and the proof explicit: ifQty' : (1 switch : Bool) -> {0 tt, ff : b} -> (1 trues : Copies (IfTrue switch) tt) -> (1 falses : Copies (IfFalse switch) ff) -> b ifQty' False Done (More ff Done) = ff ifQty' True (More tt Done) Done = tt It makes it slightly less ergonomic since you have to write ifQty' True (More br1 Done) Done instead of ifQty True br1 br2 . In both cases we've achieved the same: An implementation of if that cannot possibly be implemented wrong. Since we can deal with if we can also deal with Either , we're going to need a linear version of it because otherwise the usage annotations don't line up: data LEither : (a, b : Type) -> Type where LLeft : (1 _ : a) -> LEither a b LRight : (1 _ : b) -> LEither a b IsRight : LEither a b -> Nat IsRight (LLeft _) = 0 IsRight (LRight _) = 1 IsLeft : LEither a b -> Nat IsLeft (LLeft _) = 1 IsLeft (LRight _) = 0 either : (0 f : (1 _ : a) -> c) -> (0 g : (1 _ : b) -> c) -> (1 e : LEither a b) -> {auto 1 lefts : Copies (IsLeft e) f} -> {auto 1 rights : Copies (IsRight e) g} -> c either f g (LLeft x) {lefts = (More f Done)} {rights = Done} = f x either f g (LRight x) {lefts = Done} {rights = (More g Done)} = g x The first post 01. Emulating exact-usage in Idris2 taked about a well-typed implementation of map on vector while counting usage. In this case we can do the same with LEither only using the function when the value is a Right and never when it's a Left : mapEither : (0 f : (1 _ : a) -> b) -> (1 e : LEither c a) -> {auto 1 fn : Copies (IsRight e) f} -> LEither c b mapEither f (LLeft x) {fn = Done } = LLeft x mapEither f (LRight x) {fn = More f Done} = LRight (f x)","title":"Exact usage and branching"},{"location":"Programming/04.%20More%20things%20with%20exact%20usage/#exact-usage-and-branching","text":"This thread from @dorchard inspired me to re-use the exact-usage hack of Idris2 to see if I could implement this particular feature of Granule . But you can also use dependence to then say whether something is used or not. For example we can make an optional (Maybe type) with a tag on it that it used to determine if a default is needed: pic.twitter.com/lBugAZn3lp \u2014 Dominic Orchard (@dorchard) October 20, 2021 By the way, granule is a great project full of great ideas and I strongly encourage you to take a look! Try downloading the examples and play with them, the project comes with a very nice tutorial . To make this work in Idris, we're going to use the same Copies data structure than in 01. Emulating exact-usage in Idris2 . More precisely, we need to make 1 copy of the value def if the value is missing and 0 if the value is present (since we're not going to use it). fromMaybe would then take the value def and the number of Copies we get depend on the Maybe value, we're going to call it m . So we need a way to get 0 or one depending on m , let's write this function and call it NotFound NotFound : Maybe a -> Nat NotFound Nothing = 1 NotFound (Just x) = 0 And now fromMaybe takes a value m , a default value def and a number of copies of def equal to the number returned by NotFound : fromMaybe : (1 m : Maybe a) -> (0 def : a) -> {auto 1 defs : Copies (NotFound m) def} -> a fromMaybe Nothing {defs = (More def Done)} def = def fromMaybe (Just x) {defs = Done} def = x and it works as expected! With this type signature it is impossible to implement the wrong function as the argument def won't be available if the value m is Just x . It turns out we can generalise this approach to other branching operators. For example an if function would use its first branch if the condition is true and its second branch if the condition is false. In our case it would mean that the number of copies for the first branch is equal to 1 for True and 0 for False and likewise (but reversed) for the second branch: IfTrue : Bool -> Nat IfTrue True = 1 IfTrue False = 0 IfFalse : Bool -> Nat IfFalse True = 0 IfFalse False = 1 ifQty : (1 switch : Bool) -> (0 tt, ff : b) -> {auto 1 trues : Copies (IfTrue switch) tt} -> {auto 1 falses : Copies (IfFalse switch) ff} -> b ifQty False tt ff {trues = Done} {falses = (More ff Done)} = ff ifQty True tt ff {trues = (More tt Done)} {falses = Done} = tt In case you find it weird to pass an argument that's never used but a proof that is used, you can do the opposite and make the value implicit and the proof explicit: ifQty' : (1 switch : Bool) -> {0 tt, ff : b} -> (1 trues : Copies (IfTrue switch) tt) -> (1 falses : Copies (IfFalse switch) ff) -> b ifQty' False Done (More ff Done) = ff ifQty' True (More tt Done) Done = tt It makes it slightly less ergonomic since you have to write ifQty' True (More br1 Done) Done instead of ifQty True br1 br2 . In both cases we've achieved the same: An implementation of if that cannot possibly be implemented wrong. Since we can deal with if we can also deal with Either , we're going to need a linear version of it because otherwise the usage annotations don't line up: data LEither : (a, b : Type) -> Type where LLeft : (1 _ : a) -> LEither a b LRight : (1 _ : b) -> LEither a b IsRight : LEither a b -> Nat IsRight (LLeft _) = 0 IsRight (LRight _) = 1 IsLeft : LEither a b -> Nat IsLeft (LLeft _) = 1 IsLeft (LRight _) = 0 either : (0 f : (1 _ : a) -> c) -> (0 g : (1 _ : b) -> c) -> (1 e : LEither a b) -> {auto 1 lefts : Copies (IsLeft e) f} -> {auto 1 rights : Copies (IsRight e) g} -> c either f g (LLeft x) {lefts = (More f Done)} {rights = Done} = f x either f g (LRight x) {lefts = Done} {rights = (More g Done)} = g x The first post 01. Emulating exact-usage in Idris2 taked about a well-typed implementation of map on vector while counting usage. In this case we can do the same with LEither only using the function when the value is a Right and never when it's a Left : mapEither : (0 f : (1 _ : a) -> b) -> (1 e : LEither c a) -> {auto 1 fn : Copies (IsRight e) f} -> LEither c b mapEither f (LLeft x) {fn = Done } = LLeft x mapEither f (LRight x) {fn = More f Done} = LRight (f x)","title":"Exact usage and branching"},{"location":"Programming/05.%20Data%20Generic%20Programming/","text":"Data Generic programming \u00b6 The other day this tweet showed up. Q for Swift devs: I have an array of objects. I want to turn it into 3 arrays based on a property of each object. ArrayA = objects with property value A, ArrayB with value B, then objects with any other value for that property in a 3rd array. Any better way than using filter x3? \u2014 Belle \ud83d\udd14 B. Cooper (@BelleBCooper) November 9, 2021 I like those questions because they ask for multiple questions at once: What APIs are available to achieve this goal? What tradeoffs are available in this particular situation? What is the most idiomatic in this language? And finding an answer that fits all those questions is quite a challenge In this specific instance there seem to have two main solutions: 1. Use a fold \u00b6 fold is called reduce in switft but the idea is the same: func split3<A, S>(arr: S, test: (A) -> Three) -> ([A],[A],[A]) where S: Sequence, S.Element == A { arr.reduce(into: ([],[],[])) { acc, i in switch test(i) { case .first: acc.0.append(i) case .second: acc.1.append(i) case .third: acc.2.append(i) } } } Here i'm using a custom data type Three which has three possible values: enum Three: Equatable { case first, second, third } The reduce implementation is using an accumulator of three empty arrays and adds element to the correct one depending on which of the three value the original array maps into. This has the benefit to iterate the array only once, it's also a single expression instead of using multiple imperative statements, that meanst that you can't reorder the lines without stopping the program from compiling. The problem is that it's not particularly readable 2. Use a loop \u00b6 One of the bread and butters of c programmers is to use loops instead of higher order functions, this situation lends itself very well to a loop since accessing the arrays from within the loop feels very natural: func splitLoop<A, S>(arr: S, test: (A) -> Three) -> ([A],[A],[A]) where S: Sequence, S.Element == A { var arr1: [A] = [] var arr2: [A] = [] var arr3: [A] = [] for i in arr { switch test(i) { case .first: arr1.append(i) case .second: arr2.append(i) case .third: arr3.append(i) } } return (arr1,arr2,arr3) } This code is a bit longer but is fairly easy to understand, however it's a bit verbose and it introduces a new possible source of errors compared to the previous option: Nothing stops you from returning (arr1, arr1, arr1) or (arr1, arr2, arr1) . Of course that's a trivial bug to fix but not a trivial bug to detect since the compiler won't warn you. The pragmatic solution \u00b6 Using 3 filter turns out to produce a solution that's short, easy to read and easy to understand: func splitFilter<A, S>(arr: S, test: (A) -> Three) -> ([A],[A],[A]) where S: Sequence, S.Element == A { let arr1 = arr.filter { i in test(i) == .first } let arr2 = arr.filter { i in test(i) == .second } let arr3 = arr.filter { i in test(i) == .third } return (arr1, arr2, arr3) } This has the same problem that you can flip around the return value but the rest of the body of the function is really nice to read! It's a bit unsatisfying because it traverses the list three times instead of once but you could argue that's just a constant factor in an otherwise O(n) solution. Solving the generic version \u00b6 The question that popped into my mind was as follow: if filter allows you to partition your functions in 2, and split partitions our function in 3, is there a version that splits any array into n ? There are many ways of solving this problem but they all involve some sort of gymnasitc to do with meta-programming or macros. Thankfully you need none of that if you use Idris . There are two key observations to make to reach a solution: We need to be generic over n which will be the number of ways we partition our original array We need to be generic over the type of the predicate: It needs to have n different values in order to discriminate which \"bucket\" each value is going to end up in. Using the first observation we know we have to implement a function that looks a bit like this: splitN : (n : Nat) -> (pred : a -> ???) -> (ls : List a) -> Vect n (List a) The first argument n is the number of ways we split our list pred is the predicate that tells us which \"bucket\" each element is supposed to land in ls : List a is the original list we want to split. Vect n (List a) are our n buckets that contains all the elements from the original list but placed in their corresponding batch. I've left the return type of pred a mystery because before I tell you what it is we need to understand what it does. pred is a function that, given any value of the array, tells you \"which bucket\" the value belongs to. If there are three possible buckets, like in the original tweet, then ??? must be a type like Three that we saw earlier. But if there are only 2 buckets, then ??? should be Bool ! because we want to split our list into two possible partitions: the one for which pred is true and the one for which pred is false. If we are looking to split our array in 4 then we need a type that has four possible values, and elements that map into the first value will end up in the first bucket, elements that map to the second value end up in the second bucket, etc. So that means the type of ??? is a type that has exactly as many inhabitants (aka as many values ) as n . Generic data descriptors \u00b6 The following is the foundation of what makes Typedefs possible: an algebra of types. This interpretation is given by the wonderful thesis by Peter Morris Constructing Universes for Generic Programming (You can probably find it on the internet if you look hard enough). Long story short we need this data type: -- CFT stands for \"Context Free Type\" data CFT : Type where -- Void Zero : CFT -- Unit One : CFT -- Algebraic definitions (+) : (a, b : CFT) -> CFT (*) : (a, b : CFT) -> CFT (I've eluded variables, application and Mu because they are not used for what we are doing now) This data type describes strictly positive types and allows you to build bigger types out of smaller ones. Here Zero represents the type with 0 inhabitants, and One the type with exactly one value, this is often referred to as the unit type . * and + refer to products and coproducts of types, in layman's words, \"pairing\" of types and \"eithering\" of types. In order to represent a value with 2 in habitants it is enough to write Two : CFT Two = One + One Three can be defined as Two + One , and Four as Three + One etc. each of them allow you describe a type of exactly the same number of different values as their names. So Two has two possible values. We can automate the process by writing a function that converts from Nat to CFT by creating a description for a type with the number of values corresponding to the Nat value: TyFromNat : Nat -> CFT TyFromNat Z = Zero TyFromNat (S k) = One + TyFromNat k Since CFT is just a description for a type we need to instanciate it as a Type in the host language, Idris: data Ty : CFT -> Type where Left : Ty s -> Ty (s + t) Right : Ty t -> Ty (s + t) Unit : Ty One Pair : Ty s -> Ty t -> Ty (s * t) (Again I've eluded things we don't care about like contexts and Mu) This allow us to create values for each of our type descriptions: FunnyBool : Type FunnyBool = Ty (TyFromNat 2) FunnyTrue : FunnyBool FunnyTrue = Left Unit FunnyFalse : FunnyBool FunnyFalse = Right (Left Unit) Here Left Unit has type Ty (TyFromNat 2) , you might be confused as to why this means and that's because it means nothing . However, we, as humans, are going to assign the meaning \"true\" to this value, that's why It's called \"FunnyTrue\" and has type \"funnyBool\", same thing for \"False\" Equipped with this power we can defined a function generic over the number of buckets we want to sort our list into, as well as the type of the function necessary in order to select the correct buckets: Implementing the generic split function \u00b6 The full type signature makes use of what we've just defined with CFT , TyFromNat and Ty : splitN : (n : Nat) -> (pred : a -> Ty (TyFromNat n)) -> (ls : List a) -> Vect n (List a) Now we see that the predicate must return a value which precisely tells us which bucket the value ends up in, if n is two then there are two buckets and our function is basically a boolean predicate, if n is three we are in the same position as our original problem. The full implementation is fairly straightforward despite the complexity of the type signature. It involves doing nothing when the list is empty, and making a recursive call when it's not. In the recursive case we need to remember to insert the head of the list in the correct bucket, for this we use an auxillary function addToCorrectBucket : addToCorrectBucket : (value : a) -> {n : Nat} -> (choice : Ty (TyFromNat n) []) -> (vect : Vect n (List a)) -> Vect n (List a) addToCorrectBucket value {n = 0} choice [] = [] -- when there are no buckets -- then don't do anything addToCorrectBucket value {n = (S k)} (Left Unit) (y :: xs) = (value :: y) :: xs -- if we found the bucket (y), leave the rest of the list -- as is (xs) , but add the value to the bucket addToCorrectBucket value {n = (S k)} (Right x) (y :: xs) = y :: addToCorrectBucket value x xs -- if this bucket (y) is not the correct -- bucket then just keep going and don't -- modify it splitN : (n : Nat) -> (pred : a -> Ty (TyFromNat n)) -> (ls : List a) -> Vect n (List a) splitN n p [] = replicate n [] -- If we've gone through the entire list -- retrn `n` empty buckets splitN n p (x :: xs) = let check = p x rec = splitN n p xs in addToCorrectBucket x check rec With this we can write a simple test to partition a list in two: splitN 2 (fromBool . isEven) [1 .. 4] ( fromBool is just a way to conver from Bool to Ty (TyFromNat 2) so that the types align correctly) and we get [[2,4], [1,3]] as expected. Just to make sure I also wrote a test that sorts out polynomial into 3 buckets: the first one if they have 2 real solutions, the second one if they have 1 solution and the last one if they have no solutions: record Polynomial where constructor MkPoly x2 : Int -- x squared term x : Int -- x term c : Int -- constant term -- A polynomial a * x^2 + b * x + c has -- 2 solutions if b^2 - 4*a*c > 0 -- 1 solution if b^2 - 4*a*c === 0 -- 0 solutions if b^2 - 4*a*c < 0 solutions : Polynomial -> Ty (TyFromNat 3) [] solutions (MkPoly a b c) = let v = b * b - 4 * a * c in if v > 0 then Left Unit -- 2 solutions else if v == 0 then Right (Left Unit) -- 1 solution else Right (Right (Left Unit)) -- no solutions poly1 : Polynomial poly1 = MkPoly 2 1 3 -- 0 solutions poly2 : Polynomial poly2 = MkPoly (-1) 2 3 -- 2 solutions poly3 : Polynomial poly3 = MkPoly 1 2 1 -- 1 solution split3Test : splitN 3 Splits.solutions [Splits.poly1, Splits.poly2, Splits.poly3] === [[Splits.poly2],[Splits.poly3],[Splits.poly1]] The last line tells us that splitN 3 solutions [poly1, poly2, poly3] indeed sorts each polynomial into the correct bucket: [ [poly2] -- 2 solutions , [poly3] -- 1 solution , [poly1] -- 0 solutions ] Conclusion \u00b6 Type descriptions are nice, we can do all sorts of things without having to resort to macros or code-generation. This means we can use the same function for multiple uses. In this instance we could highly optimise our traversal of the list and every call to splitN would benefit from it. It also makes the code a lot more uniform to read since now there is no difference anymore between partitionning in 2, 3 or 4 parts, no need to write special functions for those cases. See https://github.com/idris-lang/Idris2/wiki/Types-meta-programming-manifesto for a list of idea of things we can try with them, additionally typedefs was written using the same principles.","title":"Data Generic programming"},{"location":"Programming/05.%20Data%20Generic%20Programming/#data-generic-programming","text":"The other day this tweet showed up. Q for Swift devs: I have an array of objects. I want to turn it into 3 arrays based on a property of each object. ArrayA = objects with property value A, ArrayB with value B, then objects with any other value for that property in a 3rd array. Any better way than using filter x3? \u2014 Belle \ud83d\udd14 B. Cooper (@BelleBCooper) November 9, 2021 I like those questions because they ask for multiple questions at once: What APIs are available to achieve this goal? What tradeoffs are available in this particular situation? What is the most idiomatic in this language? And finding an answer that fits all those questions is quite a challenge In this specific instance there seem to have two main solutions:","title":"Data Generic programming"},{"location":"Programming/05.%20Data%20Generic%20Programming/#1-use-a-fold","text":"fold is called reduce in switft but the idea is the same: func split3<A, S>(arr: S, test: (A) -> Three) -> ([A],[A],[A]) where S: Sequence, S.Element == A { arr.reduce(into: ([],[],[])) { acc, i in switch test(i) { case .first: acc.0.append(i) case .second: acc.1.append(i) case .third: acc.2.append(i) } } } Here i'm using a custom data type Three which has three possible values: enum Three: Equatable { case first, second, third } The reduce implementation is using an accumulator of three empty arrays and adds element to the correct one depending on which of the three value the original array maps into. This has the benefit to iterate the array only once, it's also a single expression instead of using multiple imperative statements, that meanst that you can't reorder the lines without stopping the program from compiling. The problem is that it's not particularly readable","title":"1. Use a fold"},{"location":"Programming/05.%20Data%20Generic%20Programming/#2-use-a-loop","text":"One of the bread and butters of c programmers is to use loops instead of higher order functions, this situation lends itself very well to a loop since accessing the arrays from within the loop feels very natural: func splitLoop<A, S>(arr: S, test: (A) -> Three) -> ([A],[A],[A]) where S: Sequence, S.Element == A { var arr1: [A] = [] var arr2: [A] = [] var arr3: [A] = [] for i in arr { switch test(i) { case .first: arr1.append(i) case .second: arr2.append(i) case .third: arr3.append(i) } } return (arr1,arr2,arr3) } This code is a bit longer but is fairly easy to understand, however it's a bit verbose and it introduces a new possible source of errors compared to the previous option: Nothing stops you from returning (arr1, arr1, arr1) or (arr1, arr2, arr1) . Of course that's a trivial bug to fix but not a trivial bug to detect since the compiler won't warn you.","title":"2. Use a loop"},{"location":"Programming/05.%20Data%20Generic%20Programming/#the-pragmatic-solution","text":"Using 3 filter turns out to produce a solution that's short, easy to read and easy to understand: func splitFilter<A, S>(arr: S, test: (A) -> Three) -> ([A],[A],[A]) where S: Sequence, S.Element == A { let arr1 = arr.filter { i in test(i) == .first } let arr2 = arr.filter { i in test(i) == .second } let arr3 = arr.filter { i in test(i) == .third } return (arr1, arr2, arr3) } This has the same problem that you can flip around the return value but the rest of the body of the function is really nice to read! It's a bit unsatisfying because it traverses the list three times instead of once but you could argue that's just a constant factor in an otherwise O(n) solution.","title":"The pragmatic solution"},{"location":"Programming/05.%20Data%20Generic%20Programming/#solving-the-generic-version","text":"The question that popped into my mind was as follow: if filter allows you to partition your functions in 2, and split partitions our function in 3, is there a version that splits any array into n ? There are many ways of solving this problem but they all involve some sort of gymnasitc to do with meta-programming or macros. Thankfully you need none of that if you use Idris . There are two key observations to make to reach a solution: We need to be generic over n which will be the number of ways we partition our original array We need to be generic over the type of the predicate: It needs to have n different values in order to discriminate which \"bucket\" each value is going to end up in. Using the first observation we know we have to implement a function that looks a bit like this: splitN : (n : Nat) -> (pred : a -> ???) -> (ls : List a) -> Vect n (List a) The first argument n is the number of ways we split our list pred is the predicate that tells us which \"bucket\" each element is supposed to land in ls : List a is the original list we want to split. Vect n (List a) are our n buckets that contains all the elements from the original list but placed in their corresponding batch. I've left the return type of pred a mystery because before I tell you what it is we need to understand what it does. pred is a function that, given any value of the array, tells you \"which bucket\" the value belongs to. If there are three possible buckets, like in the original tweet, then ??? must be a type like Three that we saw earlier. But if there are only 2 buckets, then ??? should be Bool ! because we want to split our list into two possible partitions: the one for which pred is true and the one for which pred is false. If we are looking to split our array in 4 then we need a type that has four possible values, and elements that map into the first value will end up in the first bucket, elements that map to the second value end up in the second bucket, etc. So that means the type of ??? is a type that has exactly as many inhabitants (aka as many values ) as n .","title":"Solving the generic version"},{"location":"Programming/05.%20Data%20Generic%20Programming/#generic-data-descriptors","text":"The following is the foundation of what makes Typedefs possible: an algebra of types. This interpretation is given by the wonderful thesis by Peter Morris Constructing Universes for Generic Programming (You can probably find it on the internet if you look hard enough). Long story short we need this data type: -- CFT stands for \"Context Free Type\" data CFT : Type where -- Void Zero : CFT -- Unit One : CFT -- Algebraic definitions (+) : (a, b : CFT) -> CFT (*) : (a, b : CFT) -> CFT (I've eluded variables, application and Mu because they are not used for what we are doing now) This data type describes strictly positive types and allows you to build bigger types out of smaller ones. Here Zero represents the type with 0 inhabitants, and One the type with exactly one value, this is often referred to as the unit type . * and + refer to products and coproducts of types, in layman's words, \"pairing\" of types and \"eithering\" of types. In order to represent a value with 2 in habitants it is enough to write Two : CFT Two = One + One Three can be defined as Two + One , and Four as Three + One etc. each of them allow you describe a type of exactly the same number of different values as their names. So Two has two possible values. We can automate the process by writing a function that converts from Nat to CFT by creating a description for a type with the number of values corresponding to the Nat value: TyFromNat : Nat -> CFT TyFromNat Z = Zero TyFromNat (S k) = One + TyFromNat k Since CFT is just a description for a type we need to instanciate it as a Type in the host language, Idris: data Ty : CFT -> Type where Left : Ty s -> Ty (s + t) Right : Ty t -> Ty (s + t) Unit : Ty One Pair : Ty s -> Ty t -> Ty (s * t) (Again I've eluded things we don't care about like contexts and Mu) This allow us to create values for each of our type descriptions: FunnyBool : Type FunnyBool = Ty (TyFromNat 2) FunnyTrue : FunnyBool FunnyTrue = Left Unit FunnyFalse : FunnyBool FunnyFalse = Right (Left Unit) Here Left Unit has type Ty (TyFromNat 2) , you might be confused as to why this means and that's because it means nothing . However, we, as humans, are going to assign the meaning \"true\" to this value, that's why It's called \"FunnyTrue\" and has type \"funnyBool\", same thing for \"False\" Equipped with this power we can defined a function generic over the number of buckets we want to sort our list into, as well as the type of the function necessary in order to select the correct buckets:","title":"Generic data descriptors"},{"location":"Programming/05.%20Data%20Generic%20Programming/#implementing-the-generic-split-function","text":"The full type signature makes use of what we've just defined with CFT , TyFromNat and Ty : splitN : (n : Nat) -> (pred : a -> Ty (TyFromNat n)) -> (ls : List a) -> Vect n (List a) Now we see that the predicate must return a value which precisely tells us which bucket the value ends up in, if n is two then there are two buckets and our function is basically a boolean predicate, if n is three we are in the same position as our original problem. The full implementation is fairly straightforward despite the complexity of the type signature. It involves doing nothing when the list is empty, and making a recursive call when it's not. In the recursive case we need to remember to insert the head of the list in the correct bucket, for this we use an auxillary function addToCorrectBucket : addToCorrectBucket : (value : a) -> {n : Nat} -> (choice : Ty (TyFromNat n) []) -> (vect : Vect n (List a)) -> Vect n (List a) addToCorrectBucket value {n = 0} choice [] = [] -- when there are no buckets -- then don't do anything addToCorrectBucket value {n = (S k)} (Left Unit) (y :: xs) = (value :: y) :: xs -- if we found the bucket (y), leave the rest of the list -- as is (xs) , but add the value to the bucket addToCorrectBucket value {n = (S k)} (Right x) (y :: xs) = y :: addToCorrectBucket value x xs -- if this bucket (y) is not the correct -- bucket then just keep going and don't -- modify it splitN : (n : Nat) -> (pred : a -> Ty (TyFromNat n)) -> (ls : List a) -> Vect n (List a) splitN n p [] = replicate n [] -- If we've gone through the entire list -- retrn `n` empty buckets splitN n p (x :: xs) = let check = p x rec = splitN n p xs in addToCorrectBucket x check rec With this we can write a simple test to partition a list in two: splitN 2 (fromBool . isEven) [1 .. 4] ( fromBool is just a way to conver from Bool to Ty (TyFromNat 2) so that the types align correctly) and we get [[2,4], [1,3]] as expected. Just to make sure I also wrote a test that sorts out polynomial into 3 buckets: the first one if they have 2 real solutions, the second one if they have 1 solution and the last one if they have no solutions: record Polynomial where constructor MkPoly x2 : Int -- x squared term x : Int -- x term c : Int -- constant term -- A polynomial a * x^2 + b * x + c has -- 2 solutions if b^2 - 4*a*c > 0 -- 1 solution if b^2 - 4*a*c === 0 -- 0 solutions if b^2 - 4*a*c < 0 solutions : Polynomial -> Ty (TyFromNat 3) [] solutions (MkPoly a b c) = let v = b * b - 4 * a * c in if v > 0 then Left Unit -- 2 solutions else if v == 0 then Right (Left Unit) -- 1 solution else Right (Right (Left Unit)) -- no solutions poly1 : Polynomial poly1 = MkPoly 2 1 3 -- 0 solutions poly2 : Polynomial poly2 = MkPoly (-1) 2 3 -- 2 solutions poly3 : Polynomial poly3 = MkPoly 1 2 1 -- 1 solution split3Test : splitN 3 Splits.solutions [Splits.poly1, Splits.poly2, Splits.poly3] === [[Splits.poly2],[Splits.poly3],[Splits.poly1]] The last line tells us that splitN 3 solutions [poly1, poly2, poly3] indeed sorts each polynomial into the correct bucket: [ [poly2] -- 2 solutions , [poly3] -- 1 solution , [poly1] -- 0 solutions ]","title":"Implementing the generic split function"},{"location":"Programming/05.%20Data%20Generic%20Programming/#conclusion","text":"Type descriptions are nice, we can do all sorts of things without having to resort to macros or code-generation. This means we can use the same function for multiple uses. In this instance we could highly optimise our traversal of the list and every call to splitN would benefit from it. It also makes the code a lot more uniform to read since now there is no difference anymore between partitionning in 2, 3 or 4 parts, no need to write special functions for those cases. See https://github.com/idris-lang/Idris2/wiki/Types-meta-programming-manifesto for a list of idea of things we can try with them, additionally typedefs was written using the same principles.","title":"Conclusion"},{"location":"Programming/06.%20Lists%2C%20Colists%20and%20Streams/","text":"Differences between List Colist and Stream \u00b6 A List is a finite datastructure containing multiple elements, possibly 0. a Stream is an infinite datastructure, it always produces elements when queried. This also means it contains at least one element. A CoList is a possibly infinite list of elements, possibly 0. Definitions \u00b6 data List a = Nil | (::) a (List a) record stream (a : Type) where constructor (::) head : a tail : Inf (Stream a) data CoList a = Nil | (::) a (Inf (Stream a)) So a List is a finite Colist and a Stream is an infinite CoList Maybe CoList and Stream should be flipped so both List and CoList are derivable from Stream ?","title":"Differences between `List` `Colist` and `Stream`"},{"location":"Programming/06.%20Lists%2C%20Colists%20and%20Streams/#differences-between-list-colist-and-stream","text":"A List is a finite datastructure containing multiple elements, possibly 0. a Stream is an infinite datastructure, it always produces elements when queried. This also means it contains at least one element. A CoList is a possibly infinite list of elements, possibly 0.","title":"Differences between List Colist and Stream"},{"location":"Programming/06.%20Lists%2C%20Colists%20and%20Streams/#definitions","text":"data List a = Nil | (::) a (List a) record stream (a : Type) where constructor (::) head : a tail : Inf (Stream a) data CoList a = Nil | (::) a (Inf (Stream a)) So a List is a finite Colist and a Stream is an infinite CoList Maybe CoList and Stream should be flipped so both List and CoList are derivable from Stream ?","title":"Definitions"},{"location":"Programming/07.%20Introduction%20to%20dependent%20types/","text":"07 Introduction to dependent types \u00b6 This is a written summary of a presentation for BCS on the 29th of March 2022. Main thread: dependent type for pratical purposes / industry Goal of dependent types: Avoid mistakes Constrain programs Prove things Benefits: Informative types Informative errors Interactive editing Avoiding mistakes \u00b6 Find the bug in this program first of list In Idris this would be a type error Constrain programs \u00b6 Here we can call this API with an empty string DateFormat format = new SimpleDataFormat(\"\") But in idris this would be a type error main = let myFormat = Main.fromString \"yyyy/MM/dd\" in printLn myFormat Error: While processing right hand side of main. Can't find an implementation for StringFormat \"\". Prove things \u00b6 find an API where you just did something but you still have to check for it Additional benefits \u00b6 Informative types Informative errors Interactive editing Informative types \u00b6 Server API in the type CLI options in the type Informative errors \u00b6 Show example of unhelpful errors Show exmaple of helpful error Interactive editing \u00b6 Show type-at Show jump to definition Show skeleton definition Show expression search Show module browsing My research: Servers and dependent types \u00b6 write the type and the the server write the server and then infer the type write the description and generate the server","title":"07 Introduction to dependent types"},{"location":"Programming/07.%20Introduction%20to%20dependent%20types/#07-introduction-to-dependent-types","text":"This is a written summary of a presentation for BCS on the 29th of March 2022. Main thread: dependent type for pratical purposes / industry Goal of dependent types: Avoid mistakes Constrain programs Prove things Benefits: Informative types Informative errors Interactive editing","title":"07 Introduction to dependent types"},{"location":"Programming/07.%20Introduction%20to%20dependent%20types/#avoiding-mistakes","text":"Find the bug in this program first of list In Idris this would be a type error","title":"Avoiding mistakes"},{"location":"Programming/07.%20Introduction%20to%20dependent%20types/#constrain-programs","text":"Here we can call this API with an empty string DateFormat format = new SimpleDataFormat(\"\") But in idris this would be a type error main = let myFormat = Main.fromString \"yyyy/MM/dd\" in printLn myFormat Error: While processing right hand side of main. Can't find an implementation for StringFormat \"\".","title":"Constrain programs"},{"location":"Programming/07.%20Introduction%20to%20dependent%20types/#prove-things","text":"find an API where you just did something but you still have to check for it","title":"Prove things"},{"location":"Programming/07.%20Introduction%20to%20dependent%20types/#additional-benefits","text":"Informative types Informative errors Interactive editing","title":"Additional benefits"},{"location":"Programming/07.%20Introduction%20to%20dependent%20types/#informative-types","text":"Server API in the type CLI options in the type","title":"Informative types"},{"location":"Programming/07.%20Introduction%20to%20dependent%20types/#informative-errors","text":"Show example of unhelpful errors Show exmaple of helpful error","title":"Informative errors"},{"location":"Programming/07.%20Introduction%20to%20dependent%20types/#interactive-editing","text":"Show type-at Show jump to definition Show skeleton definition Show expression search Show module browsing","title":"Interactive editing"},{"location":"Programming/07.%20Introduction%20to%20dependent%20types/#my-research-servers-and-dependent-types","text":"write the type and the the server write the server and then infer the type write the description and generate the server","title":"My research: Servers and dependent types"},{"location":"Task%20Management/Control%20room/","text":"A character input method based on game controllers. Goal: - provide alternative I put methods for accessibility purposes - Provide a fast input method for controller-based games - Provide an anternative interface for text editor that allows portable devices such as tablets or steam deck as writing tools 11 Control room \u00b6 Connect to controller \u2705 2022-03-21 Obtain joystick angle \u2705 2022-04-03 convert angle into publishers \u2705 2022-04-10 get the publisher to print something on the UI setup git \u2705 2022-04-10 Test on iOS \u2705 2022-04-10 Collect inputs into a string buffer Make a view for the joystick input","title":"Control room"},{"location":"Task%20Management/Control%20room/#11-control-room","text":"Connect to controller \u2705 2022-03-21 Obtain joystick angle \u2705 2022-04-03 convert angle into publishers \u2705 2022-04-10 get the publisher to print something on the UI setup git \u2705 2022-04-10 Test on iOS \u2705 2022-04-10 Collect inputs into a string buffer Make a view for the joystick input","title":"11 Control room"},{"location":"Task%20Management/Data%20Generic%20Programming/","text":"7 Data generic programming \u00b6 7.3 write the blog post about CFT 7.6 write blog post about Zippers 7.7 Add coproducts to Records?","title":"7 Data generic programming"},{"location":"Task%20Management/Data%20Generic%20Programming/#7-data-generic-programming","text":"7.3 write the blog post about CFT 7.6 write blog post about Zippers 7.7 Add coproducts to Records?","title":"7 Data generic programming"},{"location":"Task%20Management/Graphics/","text":"9 Graphics \u00b6 9.1 Draw logo for DJSON 9.3 Draw logo for Prolude 9.4 update logo for Open servers 9.5 Draw logo for AOC","title":"9 Graphics"},{"location":"Task%20Management/Graphics/#9-graphics","text":"9.1 Draw logo for DJSON 9.3 Draw logo for Prolude 9.4 update logo for Open servers 9.5 Draw logo for AOC","title":"9 Graphics"},{"location":"Task%20Management/Idris%20Profficiency/","text":"8 Idris proefficiency tutorial \u00b6 8.3 write about data types 8.4 write about IO 8.5 write about common functions 8.6 write about syntax 8.7 write instructions to install and use 8.8 port the new functions to prolude and refactor AOC 2021 (07.12.2021) 8.8.1 Day 1 (07.12.2021) 8.8.2 Day 2 (07.12.2021) 8.8.3 Day 3 (07.12.2021) 8.8.4 Day 4 (07.12.2021) 8.8.5 Day 5 (07.12.2021) 8.8.6 Day 6 (07.12.2021) 8.8.7 Day 7 (07.12.2021) 8.8.8 Day 8 8.8.9 Day 9 8.8.10 Day 10 8.8.11 Day 11 8.8.12 Day 12","title":"8 Idris proefficiency tutorial"},{"location":"Task%20Management/Idris%20Profficiency/#8-idris-proefficiency-tutorial","text":"8.3 write about data types 8.4 write about IO 8.5 write about common functions 8.6 write about syntax 8.7 write instructions to install and use 8.8 port the new functions to prolude and refactor AOC 2021 (07.12.2021) 8.8.1 Day 1 (07.12.2021) 8.8.2 Day 2 (07.12.2021) 8.8.3 Day 3 (07.12.2021) 8.8.4 Day 4 (07.12.2021) 8.8.5 Day 5 (07.12.2021) 8.8.6 Day 6 (07.12.2021) 8.8.7 Day 7 (07.12.2021) 8.8.8 Day 8 8.8.9 Day 9 8.8.10 Day 10 8.8.11 Day 11 8.8.12 Day 12","title":"8 Idris proefficiency tutorial"},{"location":"Task%20Management/Mailbox/","text":"Mailbox : \u00b6 Use idris-hedgehog to generate functions for equilibrium checking NOTE: The goal is to, given a pair of types, generate all functions from one type to the other. (a, b : Type) -> Stream (a -> b) /!\\ Complete support for ipkg in sirdi \u2705 2022-03-07 Support cloning git \u2705 2022-02-06 NOTE: we need to pull the repository into a temp directory checkout and then copy back into sources Support legacy instructions \u2705 2022-02-06 NOTE: We need to know where the ipkg file is, and then run the install script# Mailbox split tasks into smaller files and use quick add to add items to them \u2705 2022-03-18 permutations Fin n -> a \u2705 2022-03-22 connect to the game controller \u2705 2022-03-21 finish preparing talk to BCS \u2705 2022-04-15 permutations, make a type that track values that have been plucked out Setup the benchmark server Install OS \u2705 2022-03-28 Setup SSH keys Setup Mosh Install Idris + Chez Run some benchmarks \u2705 2022-04-10 Download some benchmarks \u2705 2022-04-10 Run the benchmarks \u2705 2022-04-10 submit apache-mime-types and tyttp to pack \u2705 2022-07-12 State machines to containers in Haskell Functions to containers in haskell","title":"Mailbox :"},{"location":"Task%20Management/Mailbox/#mailbox","text":"Use idris-hedgehog to generate functions for equilibrium checking NOTE: The goal is to, given a pair of types, generate all functions from one type to the other. (a, b : Type) -> Stream (a -> b) /!\\ Complete support for ipkg in sirdi \u2705 2022-03-07 Support cloning git \u2705 2022-02-06 NOTE: we need to pull the repository into a temp directory checkout and then copy back into sources Support legacy instructions \u2705 2022-02-06 NOTE: We need to know where the ipkg file is, and then run the install script# Mailbox split tasks into smaller files and use quick add to add items to them \u2705 2022-03-18 permutations Fin n -> a \u2705 2022-03-22 connect to the game controller \u2705 2022-03-21 finish preparing talk to BCS \u2705 2022-04-15 permutations, make a type that track values that have been plucked out Setup the benchmark server Install OS \u2705 2022-03-28 Setup SSH keys Setup Mosh Install Idris + Chez Run some benchmarks \u2705 2022-04-10 Download some benchmarks \u2705 2022-04-10 Run the benchmarks \u2705 2022-04-10 submit apache-mime-types and tyttp to pack \u2705 2022-07-12 State machines to containers in Haskell Functions to containers in haskell","title":"Mailbox :"},{"location":"Task%20Management/Myrmidon/","text":"3 Myrmidon language \u00b6 3.3 Add Vect 3.4 Add Fins NOTE: Important for indexing vectors 3.5 Add Bools NOTE: Important for if-then-else 3.6 Write tests 3.6.1 Write parser tests (15.11.2021) 3.6.2 /!\\ Read files and execute them \u2705 2022-03-31 3.6.3 Read files and compile them \u2705 2022-03-31 3.6.4 figure out how to run a file from the haskell version 3.6.5 Write compiler tests based on the haskell version 3.7 Experiment with compiler passes NOTE: Attempt to run linearity checking twice in a row to simulate a biaised semiring by partially evaluating things that are True and then typechecking again to see that none of the erased quantities remain. 3.8 Add the funky semiring for both uses and stages 3.8.1 write definition (07.12.2021) 3.8.3 prove that it's actually a semiring 3.9 implement co-debruijn indices 3.11 write a REPL 3.12 attempt a affine type system using 0 , 0-1 , 1 , 1-\u03c9 and \u03c9 where 0<\u03c9 , 1 < 1-\u03c9 and 0-1 < 1 3.13 add data types and case 3.14 linearity 3.14.1 figure out multiplicty inference The problem when desugaring an applicaton is taht we do not know which multiplicity to use 3.14.2 implement erasure 3.14.3 Implement linearity constraints 3.15 implement scheme backend note: currently we export s-expr but it would be nice to have a way to run those program 3.16 Figure out pattern matching","title":"3 Myrmidon language"},{"location":"Task%20Management/Myrmidon/#3-myrmidon-language","text":"3.3 Add Vect 3.4 Add Fins NOTE: Important for indexing vectors 3.5 Add Bools NOTE: Important for if-then-else 3.6 Write tests 3.6.1 Write parser tests (15.11.2021) 3.6.2 /!\\ Read files and execute them \u2705 2022-03-31 3.6.3 Read files and compile them \u2705 2022-03-31 3.6.4 figure out how to run a file from the haskell version 3.6.5 Write compiler tests based on the haskell version 3.7 Experiment with compiler passes NOTE: Attempt to run linearity checking twice in a row to simulate a biaised semiring by partially evaluating things that are True and then typechecking again to see that none of the erased quantities remain. 3.8 Add the funky semiring for both uses and stages 3.8.1 write definition (07.12.2021) 3.8.3 prove that it's actually a semiring 3.9 implement co-debruijn indices 3.11 write a REPL 3.12 attempt a affine type system using 0 , 0-1 , 1 , 1-\u03c9 and \u03c9 where 0<\u03c9 , 1 < 1-\u03c9 and 0-1 < 1 3.13 add data types and case 3.14 linearity 3.14.1 figure out multiplicty inference The problem when desugaring an applicaton is taht we do not know which multiplicity to use 3.14.2 implement erasure 3.14.3 Implement linearity constraints 3.15 implement scheme backend note: currently we export s-expr but it would be nice to have a way to run those program 3.16 Figure out pattern matching","title":"3 Myrmidon language"},{"location":"Task%20Management/Open%20Games/","text":"5 OpenGames things \u00b6 5.3 write an idris version 5.3.1 port the core opengames logic with lenses (07.11.2021) 5.3.2 port the parser (08.11.2021) 5.3.3 port the compiler (09.11.2021) 5.3.4 port the code generator (11.11.2021) 5.3.5 figure out why evaluator doesn't reduce (09.12.2021) NOTE: It works now! but it's really slow, and using the scheme evaluator fails, I don't know why yet but but it seems to be due to scheme, the generated scheme leads to an error when sent to the runtime, so the eval function returns an excepption. We catch it but we don't return its diagnostic info, so we need to change that to make it available. 5.3.6 Implement type inference NOTE: types of the block are the boundary of the lens, the states are the products of the state of the lines 5.3.7 update the scheme support file to return either rather than Maybe 5.5 Write installation instructions for the haskell version 5.6 Test the parser in the refactored version \u23eb \u2705 2022-03-18 5.6.1 port the code from vlad NOTE: change all the decision operators to use the ones from philips code (the kleisli stuff) Stuck because of 5.9 5.7 Open games implementation paper 5.7.1 Draft chapters 5.7.2 Write about scope checking 5.8 Move updated project into original repository \u23eb \u2705 2022-03-18 5.8.1 Tag Version 0.1 of Open games \u2705 2022-02-09 5.8.2 Adapt the directory structure and namespaces of Philipp's fork from old OG Master \u2705 2022-06-12 5.8.3 overwrite master with Philip's updated fork \u2705 2022-06-12 5.8.4 rewrite Jules' version in terms of the new master 5.8.5 delete Jules version \u2705 2022-06-12 5.9 /!\\ implement typed population without implementation \u2705 2022-02-03 5.10 implement AMM in terms of new types and deriving via \u2705 2022-04-22 5.10.1 implement testing from State to IO \u2705 2022-04-22 5.11 move everything to GHC 9.2 on ARM Import the given example into Open Games","title":"5 OpenGames things"},{"location":"Task%20Management/Open%20Games/#5-opengames-things","text":"5.3 write an idris version 5.3.1 port the core opengames logic with lenses (07.11.2021) 5.3.2 port the parser (08.11.2021) 5.3.3 port the compiler (09.11.2021) 5.3.4 port the code generator (11.11.2021) 5.3.5 figure out why evaluator doesn't reduce (09.12.2021) NOTE: It works now! but it's really slow, and using the scheme evaluator fails, I don't know why yet but but it seems to be due to scheme, the generated scheme leads to an error when sent to the runtime, so the eval function returns an excepption. We catch it but we don't return its diagnostic info, so we need to change that to make it available. 5.3.6 Implement type inference NOTE: types of the block are the boundary of the lens, the states are the products of the state of the lines 5.3.7 update the scheme support file to return either rather than Maybe 5.5 Write installation instructions for the haskell version 5.6 Test the parser in the refactored version \u23eb \u2705 2022-03-18 5.6.1 port the code from vlad NOTE: change all the decision operators to use the ones from philips code (the kleisli stuff) Stuck because of 5.9 5.7 Open games implementation paper 5.7.1 Draft chapters 5.7.2 Write about scope checking 5.8 Move updated project into original repository \u23eb \u2705 2022-03-18 5.8.1 Tag Version 0.1 of Open games \u2705 2022-02-09 5.8.2 Adapt the directory structure and namespaces of Philipp's fork from old OG Master \u2705 2022-06-12 5.8.3 overwrite master with Philip's updated fork \u2705 2022-06-12 5.8.4 rewrite Jules' version in terms of the new master 5.8.5 delete Jules version \u2705 2022-06-12 5.9 /!\\ implement typed population without implementation \u2705 2022-02-03 5.10 implement AMM in terms of new types and deriving via \u2705 2022-04-22 5.10.1 implement testing from State to IO \u2705 2022-04-22 5.11 move everything to GHC 9.2 on ARM Import the given example into Open Games","title":"5 OpenGames things"},{"location":"Task%20Management/Open%20servers/","text":"6 Open-Servers \u00b6 6.2 fix the Servant DSL \u23eb NOTE: After the changes to the core, the Servant examples won't work anymore issue #34 6.5 try out idris-server http server project \u2705 2022-03-14 6.5.1 run locally -- doesn't work \u2705 2021-11-10 6.5.2 Perform the suggested fixes from discord \u2705 2021-11-11 NOTE: didn't work, missing module: TyTTP.Support.Promise 6.5.2' Perform the suggested fixes from discord \u2705 2022-03-14 NOTE: Updated info from package author, need to try again! 6.5.3 see if we can interpret LogIO into the node JS server \u2705 2022-03-14 looks like this is not what we are looking for, the Tyttp library is too high level and the prototype diverged too much from Recombine [-] ~~6.7 Try out new lenses~~ [-] ~~6.7.1 try the dependent van-laarhoven~~ Functor f => ((i : a) -> {0 b : a -> Type} -> f (b i)) -> (i : s) -> {0 t : s -> Type} -> f (t i) ~~6.8 dependent lenses are morphisms between containers. Comonads are morphisms between directed containers. Can we convert from one to the other?~~ Note: they are not directed containers but database might be 6.9 Refactor the PathComp Datatype do get rid of Str constructor and use product and sum \u2705 2022-03-27 and String.Singleton instead 6.9.1 remove the use of Product and Sum and replace it with a custom type with suitable \u2705 2022-03-27 parsing functions 6.11 Take a look at Matteo's draft of the paper \u2705 2022-02-17 6.12 Allow dependent endpoints \u23eb \u2705 2022-03-14 We do not need this anymore 6.13 Tensor in the DSL \u23eb \u2705 2022-02-17 6.13.1 Finish writing the tensor examples \u2705 2022-02-17 6.14 Port indexed interfaces to container interfaces \u2705 2022-03-14 Not going to work, it messes up inference 6.15 implement state as action \u2705 2022-03-27 issue #44 6.16 implement servers as bidirectional lenses for each endpoints \u2705 2022-03-27 issue #42 6.17 finish database example BLOCKED: Need to deal with 6.18 first 6.18 add error management with co-parameter 6.18.1 Implement co-para lenses \u2705 2022-04-13 6.18.2 Implement para and co-para lenses \u2705 2022-04-13 6.18.3 Implement errors on the backward part 6.19 implement server communication with node \u2705 2022-04-13 6.20 Implement authentication and caching 6.20.1 Implement + for Indexed containers \u2705 2022-04-13 6.20.2 Implement \"my\" indexed containers as a container with a unit parameter 6.20.3 Implement caching with + on the output 6.21 Write definition of server composition language on paper \u2705 2022-07-12 6.21.1 Implement the dependently typed language using terms \u2705 2022-07-12 6.22 Write lenses as update monads and see if we can track effects \u2705 2022-05-19 NOTE: composition does not work 6.23 Find monoidal structures on Suspended containers \u2705 2022-07-12 It's not a category because there is no identity on containers 6.24 Find a unifying structure for bidirectional servers 6.24.1 embedd resource lenses into it 6.24.2 embed cache middle ware 6.24.3 embed authentication middleware","title":"6 Open-Servers"},{"location":"Task%20Management/Open%20servers/#6-open-servers","text":"6.2 fix the Servant DSL \u23eb NOTE: After the changes to the core, the Servant examples won't work anymore issue #34 6.5 try out idris-server http server project \u2705 2022-03-14 6.5.1 run locally -- doesn't work \u2705 2021-11-10 6.5.2 Perform the suggested fixes from discord \u2705 2021-11-11 NOTE: didn't work, missing module: TyTTP.Support.Promise 6.5.2' Perform the suggested fixes from discord \u2705 2022-03-14 NOTE: Updated info from package author, need to try again! 6.5.3 see if we can interpret LogIO into the node JS server \u2705 2022-03-14 looks like this is not what we are looking for, the Tyttp library is too high level and the prototype diverged too much from Recombine [-] ~~6.7 Try out new lenses~~ [-] ~~6.7.1 try the dependent van-laarhoven~~ Functor f => ((i : a) -> {0 b : a -> Type} -> f (b i)) -> (i : s) -> {0 t : s -> Type} -> f (t i) ~~6.8 dependent lenses are morphisms between containers. Comonads are morphisms between directed containers. Can we convert from one to the other?~~ Note: they are not directed containers but database might be 6.9 Refactor the PathComp Datatype do get rid of Str constructor and use product and sum \u2705 2022-03-27 and String.Singleton instead 6.9.1 remove the use of Product and Sum and replace it with a custom type with suitable \u2705 2022-03-27 parsing functions 6.11 Take a look at Matteo's draft of the paper \u2705 2022-02-17 6.12 Allow dependent endpoints \u23eb \u2705 2022-03-14 We do not need this anymore 6.13 Tensor in the DSL \u23eb \u2705 2022-02-17 6.13.1 Finish writing the tensor examples \u2705 2022-02-17 6.14 Port indexed interfaces to container interfaces \u2705 2022-03-14 Not going to work, it messes up inference 6.15 implement state as action \u2705 2022-03-27 issue #44 6.16 implement servers as bidirectional lenses for each endpoints \u2705 2022-03-27 issue #42 6.17 finish database example BLOCKED: Need to deal with 6.18 first 6.18 add error management with co-parameter 6.18.1 Implement co-para lenses \u2705 2022-04-13 6.18.2 Implement para and co-para lenses \u2705 2022-04-13 6.18.3 Implement errors on the backward part 6.19 implement server communication with node \u2705 2022-04-13 6.20 Implement authentication and caching 6.20.1 Implement + for Indexed containers \u2705 2022-04-13 6.20.2 Implement \"my\" indexed containers as a container with a unit parameter 6.20.3 Implement caching with + on the output 6.21 Write definition of server composition language on paper \u2705 2022-07-12 6.21.1 Implement the dependently typed language using terms \u2705 2022-07-12 6.22 Write lenses as update monads and see if we can track effects \u2705 2022-05-19 NOTE: composition does not work 6.23 Find monoidal structures on Suspended containers \u2705 2022-07-12 It's not a category because there is no identity on containers 6.24 Find a unifying structure for bidirectional servers 6.24.1 embedd resource lenses into it 6.24.2 embed cache middle ware 6.24.3 embed authentication middleware","title":"6 Open-Servers"},{"location":"Task%20Management/Servers%20Lens%20tutorial/","text":"10 An optic-based webserver library \u00b6 Steal content from ICFP paper Round 1 Monomorphic lenses \u2705 2022-02-08 Polymorphic lenses Lenses as servers \u2705 2022-02-06 Combining endpoints Dependent lenses Lookup affine traversals Combining endpoints\u00b2 Building servers Parsing URLs URL captures Implementing Authentication Dependent endpoints A Domain specific language for servers Another Domain Specific Language Round 2 Monomorphic lenses NOTES: Talk about the category of lenses Polymorphic lenses Lenses as servers Combining endpoints Dependent lenses Combining endpoints\u00b2 Building servers Parsing URLs URL captures Implementing Authentication Dependent endpoints A Domain specific language for servers Another Domain Specific Language","title":"10 An optic-based webserver library"},{"location":"Task%20Management/Servers%20Lens%20tutorial/#10-an-optic-based-webserver-library","text":"Steal content from ICFP paper Round 1 Monomorphic lenses \u2705 2022-02-08 Polymorphic lenses Lenses as servers \u2705 2022-02-06 Combining endpoints Dependent lenses Lookup affine traversals Combining endpoints\u00b2 Building servers Parsing URLs URL captures Implementing Authentication Dependent endpoints A Domain specific language for servers Another Domain Specific Language Round 2 Monomorphic lenses NOTES: Talk about the category of lenses Polymorphic lenses Lenses as servers Combining endpoints Dependent lenses Combining endpoints\u00b2 Building servers Parsing URLs URL captures Implementing Authentication Dependent endpoints A Domain specific language for servers Another Domain Specific Language","title":"10 An optic-based webserver library"}]}