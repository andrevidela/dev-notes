# 3 Myrmidon language
  - [ ] 3.3 Add Vect
  - [ ] 3.4 Add Fins
    - NOTE: Important for indexing vectors
  - [ ] 3.5 Add Bools
    - NOTE: Important for if-then-else
  - [ ] 3.6 Write tests
    - [x] 3.6.1 Write parser tests (15.11.2021)
    - [x] 3.6.2 /!\ Read files and execute them ✅ 2022-03-31
    - [x] 3.6.3 Read files and compile them ✅ 2022-03-31
    - [ ] 3.6.4 figure out how to run a file from the haskell version
    - [ ] 3.6.5 Write compiler tests based on the haskell version
  - [ ] 3.7 Experiment with compiler passes
      - NOTE: Attempt to run linearity checking twice in a row to simulate a biaised semiring
        by partially evaluating things that are True and then typechecking again to see that none of the
        erased quantities remain.
  - [ ] 3.8 Add the funky semiring for both uses and stages
    - [x] 3.8.1 write definition (07.12.2021)
    - [ ] 3.8.3 prove that it's actually a semiring
  - [ ] 3.9 implement co-debruijn indices
  - [ ] 3.11 write a REPL
  - [ ] 3.12 attempt a affine type system using `0`, `0-1`, `1`, `1-ω` and `ω` where `0<ω` , `1 < 1-ω` and `0-1 < 1`
  - [ ] 3.13 add data types and case
  - [ ] 3.14 linearity
      - [ ] 3.14.1 figure out multiplicty inference
	    - The problem when desugaring an applicaton is taht we do not know which multiplicity to use
      - [ ] 3.14.2 implement erasure
      - [ ] 3.14.3 Implement linearity constraints
  - [ ] 3.15 implement scheme backend
	  - note: currently we export s-expr but it would be nice to have a way to run those program
  - [ ] 3.16 Figure out pattern matching
